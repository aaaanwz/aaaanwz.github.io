<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>kubernetes on A4 tech note</title>
    <link>https://aaaanwz.github.io/categories/kubernetes/</link>
    <description>Recent content in kubernetes on A4 tech note</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Tue, 04 Jan 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://aaaanwz.github.io/categories/kubernetes/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Kubernetesに写真サーバーを構築する</title>
      <link>https://aaaanwz.github.io/post/2022/piwigo/</link>
      <pubDate>Tue, 04 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://aaaanwz.github.io/post/2022/piwigo/</guid>
      <description>2021年6月1日からGoogle Photoの容量が無制限ではなくなり、無料枠は15GBに制限されてしまいました。
完全に音楽サーバーを構築した話の二番煎じですが、自宅k8sに写真サーバーを構築してそちらに移行する事にしました。
デプロイ self-hostedな写真サーバーで最もメジャーなプロダクトはPiwigoの模様。
サクっとyamlを書いてデプロイします。
deployment.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  apiVersion: apps/v1 kind: Deployment metadata: name: piwigo spec: replicas: 1 selector: matchLabels: app: piwigo template: metadata: labels: app: piwigo spec: containers: - name: piwigo image: lscr.</description>
    </item>
    
    <item>
      <title>おうちKubernetesに音楽ストリーミングサーバー(兼ファイルサーバー)を構築する</title>
      <link>https://aaaanwz.github.io/post/2021/airsonic/</link>
      <pubDate>Thu, 02 Dec 2021 07:00:00 +0900</pubDate>
      
      <guid>https://aaaanwz.github.io/post/2021/airsonic/</guid>
      <description>神(Google)は「Play Music」と言われた。するとGoogle Play Musicがあった。
神はそのUXを見て、良しとされた。
神はまた言われた。「YouTube Musicに移行してください」
UIは使いづらく、バックグラウンド再生できず、ロードは遅くなり、楽曲メタデータは編集できなくなった。
神はお休みになった。
概要 所有している音楽データをアップロードし、インターネット経由で聴くというサービスでしっくりくるものがないため、自宅Kubernetesクラスタに自前で構築してみます。
 家庭内LANからファイルサーバーとして使える ファイルサーバーにアップロードした音楽データをインターネット経由で聴ける ファイルサイズが大きい楽曲はサーバーサイドでリアルタイムに圧縮して配信する  という要件から、以下のような構成にしてみます。
 音楽配信サーバーには Airsonicを使います  Ingress(L7ロードバランサー)経由でインターネットに接続します IngressをTLS終端にします   ファイルサーバーとしてSambaを構築します  Airsonicとストレージを共有します LoadBalancer Service(L4ロードバランサー)経由で家庭内LANに接続し、インターネットからは遮断します    構築 1. Storage まず初めに、Podからホストマシンのストレージを使うためのPersistentVolume(PV)とPersistentVolumeClaim(PVC)を作成します。 今回は node1 の /mnt/hdd に音楽データとメタデータ(設定、アカウント情報など)を永続化するとします。
pv.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  apiVersion: v1 kind: PersistentVolume metadata: name: music spec: capacity: storage: 1000Gi accessModes: - ReadWriteOnce local: path: /mnt/hdd/music nodeAffinity: required: nodeSelectorTerms: - matchExpressions: - key: kubernetes.</description>
    </item>
    
    <item>
      <title>ArgoCD GitOpsにおけるSecret管理</title>
      <link>https://aaaanwz.github.io/post/2021/argocd-vault-plugin/</link>
      <pubDate>Mon, 01 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://aaaanwz.github.io/post/2021/argocd-vault-plugin/</guid>
      <description>KubernetesでGitOps運用となると必ず話題になるのがSecretの管理です。
Sealed Secretsやkubesecなどの手元で暗号化する系
Kubernetes Secrets Store CSI Driverやkubernetes-external-secretsなどの外部シークレットストアから引っ張ってくる系
機密情報だけ別Repoにする
など様々な方法がありますが、学習コストや実運用をイメージするとどのソリューションもしっくり来ませんでした。
そんな中でIBM社が開発しているArgoCD Vault Pluginを触ってみたところ、ArgoCDのデプロイ時にplaceholderをreplaceするという合理的かつシンプルな仕組みで非常に好感触でした。 (上記でいう「外部シークレットストアから引っ張ってくる系」の一種に該当します) ArgoCD Vault Plugin (以下AVP) は日本語の情報が皆無に等しかったため、布教の目的も込めて導入・運用方法を記載します。
テスト AVPはbrewからも導入でき、手元で簡単にテストができます。 シークレットストアはAWS Secrets Mangerを使う前提で解説します。
ローカル環境にインストール (Mac) 1  $ brew install argocd-vault-plugin   AWS Secrets Mangerに機密文字列を登録する 1 2  key: my_secret value: foobar   Kubernetes Manifestを作成する Secretの実装は非常に簡単で、
 アノテーションに参照するSecret Managerのパスを記述する Secret Managerのキー名を&amp;lt;&amp;gt; で囲う  だけでOKです。
1 2 3 4 5 6 7 8  apiVersion: v1 kind: Secret metadata: name: credentials annotations: avp.</description>
    </item>
    
    <item>
      <title>Argo Workflowsの失敗時にデフォルトでSlackに通知する</title>
      <link>https://aaaanwz.github.io/post/2021/argo-workflows-exit-handler/</link>
      <pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://aaaanwz.github.io/post/2021/argo-workflows-exit-handler/</guid>
      <description>Argo workflowsでは Default Workflow Spec を設定する事でワークフローに色々とパッチできる。
以下のようにexit-handlerをworkflowDefaultsにしておくと、ワークフロー側に何も記述せずとも失敗時にSlackに通知できる。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  apiVersion: v1 kind: ConfigMap metadata: name: workflow-controller-configmap data: workflowDefaults: |spec: onExit: exit-handler templates: - name: exit-handler when: &amp;#34;{{workflow.status}} != Succeeded&amp;#34; container: image: curlimages/curl:latest args: [&amp;#34;-X&amp;#34;,&amp;#34;POST&amp;#34;,&amp;#34;-H&amp;#34;,&amp;#39;Content-type: application/json&amp;#39;,&amp;#34;--data&amp;#34;, &amp;#39;{&amp;#34;attachments&amp;#34;: [{&amp;#34;title&amp;#34;:&amp;#34;Workflow status: {{workflow.status}}&amp;#34;,&amp;#34;color&amp;#34;: &amp;#34;danger&amp;#34;,&amp;#34;fields&amp;#34;: [{&amp;#34;title&amp;#34;: &amp;#34;name&amp;#34;, &amp;#34;value&amp;#34;: &amp;#34;{{workflow.name}}&amp;#34;, &amp;#34;short&amp;#34;: true }, {&amp;#34;title&amp;#34;: &amp;#34;url&amp;#34;, &amp;#34;value&amp;#34;: &amp;#34;https://{{inputs.</description>
    </item>
    
    <item>
      <title>embulkをArgo workflowsで実行するTemplate</title>
      <link>https://aaaanwz.github.io/post/2021/argo-workflows-embulk/</link>
      <pubDate>Thu, 28 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://aaaanwz.github.io/post/2021/argo-workflows-embulk/</guid>
      <description>Argo Workflowsの公式ドキュメントが分かりづらかったので、試しにembulkを実行するテンプレートを作ってみました。
config.ymlはartifactsとして渡します。
Dockerfile 1 2 3 4 5 6 7 8 9 10 11 12 13  FROM openjdk:8-jre-alpine ARG VERSION=latest RUN mkdir -p /root/.embulk/bin \ &amp;amp;&amp;amp; wget -q https://dl.embulk.org/embulk-${VERSION}.jar -O /root/.embulk/bin/embulk \ &amp;amp;&amp;amp; chmod +x /root/.embulk/bin/embulk ENV PATH=$PATH:/root/.embulk/bin RUN apk add --no-cache libc6-compat RUN embulk gem install embulk-input-s3 ENTRYPOINT [&amp;#34;java&amp;#34;, &amp;#34;-jar&amp;#34;, &amp;#34;/root/.embulk/bin/embulk&amp;#34;]   1 2 3  $ EMBULK_VERSION=0.9.23 $ docker build . -t embulk:$EMBULK_VERSION --build-arg VERSION=$EMBULK_VERSION $ docker run -v /path/to/configfile:/config embulk:latest run /config/config.</description>
    </item>
    
    <item>
      <title>kubectl logsに任意のログを表示する</title>
      <link>https://aaaanwz.github.io/post/2021/kubectl-logs/</link>
      <pubDate>Wed, 08 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://aaaanwz.github.io/post/2021/kubectl-logs/</guid>
      <description>kubectl logsはPID1の標準出力を表示するため、直接書き込んでしまえばなんでも表示できる。
1 2 3  $ kubectl exec -it pod-xxx bash # echo &amp;#39;show as stdin&amp;#39; &amp;gt; /proc/1/fd/1 # echo &amp;#39;show as stderr&amp;#39; &amp;gt; /proc/1/fd/2   1 2 3 4  $ kubectl logs pod-xxx show as stdin show as stderr   </description>
    </item>
    
    <item>
      <title>KubernetesのCronJobからJobを手動作成する</title>
      <link>https://aaaanwz.github.io/post/2020/k8s-cron-rerun/</link>
      <pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://aaaanwz.github.io/post/2020/k8s-cron-rerun/</guid>
      <description>1  kubectl create job 作成するJob名 --from=cronjob/CronJob名   https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#-em-job-em-</description>
    </item>
    
    <item>
      <title>mavenプロジェクト作成からCIOps構築まで</title>
      <link>https://aaaanwz.github.io/post/2019/java-create-maven-project/</link>
      <pubDate>Wed, 24 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://aaaanwz.github.io/post/2019/java-create-maven-project/</guid>
      <description>git branchに変更が加わった際、
 JUnit test (with MySQL) docker build Kubernetes環境にデプロイ (CIOps)  が行われるJavaプロジェクトを構築します。
 本番運用ではArgoCDなどgitOps構築をお勧めします
 登場するもの OSS  Maven MySQL Docker  サービス  GitHub CircleCI AWS (ECR, EKS) ⇦ 微修正でその他マネージドk8sにも応用可能かと思います。  サンプルプロジェクトの実装 最終的にディレクトリ構成はこんな感じになります。順を追って作っていきます。 GitHubからcloneして頂いても結構です。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  testproject/ ├ src/ │ ├ main/ │ │ └ java/ │ │ └testpackage/ │ │ └Main.java │ └ test/ │ └ java/ │ └testpackage/ │ └MainTest.</description>
    </item>
    
    <item>
      <title>Kubernetes Liveness ProbeでJavaプロセスを監視する</title>
      <link>https://aaaanwz.github.io/post/2019/java-k8s-liveness-probe/</link>
      <pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://aaaanwz.github.io/post/2019/java-k8s-liveness-probe/</guid>
      <description>Javaプロセスを一定時間毎にチェックし、ハングしていればPodを再起動する仕組みの備忘録です。
Kubernetes LivenessProbeに関する詳細はこちらをご参照ください。
Java実装 監視対象クラス テスト用に、インスタンスが生成されてから10秒後に isAlive() == falseになるように実装します。
1 2 3 4 5 6 7 8 9 10  public class SomeResource { final long createdTime; public SomeResource() { this.createdTime = System.currentTimeMillis(); } public boolean isAlive() { return System.currentTimeMillis() - createdTime &amp;lt; 10000; } }   監視用エンドポイント SomeResource#isAlive() == trueの時はレスポンスコード 200, falseの時は 500を返すように実装します。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  import com.</description>
    </item>
    
  </channel>
</rss>
